"use strict";(self.webpackChunkmir_guia=self.webpackChunkmir_guia||[]).push([[3660],{3905:(e,a,n)=>{n.d(a,{Zo:()=>p,kt:()=>g});var r=n(7294);function o(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function t(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?t(Object(n),!0).forEach((function(a){o(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,r,o=function(e,a){if(null==e)return{};var n,r,o={},t=Object.keys(e);for(r=0;r<t.length;r++)n=t[r],a.indexOf(n)>=0||(o[n]=e[n]);return o}(e,a);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(r=0;r<t.length;r++)n=t[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var a=r.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},p=function(e){var a=c(e.components);return r.createElement(s.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},d=r.forwardRef((function(e,a){var n=e.components,o=e.mdxType,t=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=o,g=u["".concat(s,".").concat(d)]||u[d]||m[d]||t;return n?r.createElement(g,i(i({ref:a},p),{},{components:n})):r.createElement(g,i({ref:a},p))}));function g(e,a){var n=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var t=n.length,i=new Array(t);i[0]=d;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[u]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<t;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5835:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const t={},i="Programaci\xf3n funcional",l={unversionedId:"javascript/avanzado/programacion-funcional",id:"javascript/avanzado/programacion-funcional",title:"Programaci\xf3n funcional",description:"La programaci\xf3n funcional es un paradigma de la programaci\xf3n en donde las funciones se convierten en las protaginistas del c\xf3digo que escribimos.",source:"@site/docs/javascript/avanzado/programacion-funcional.md",sourceDirName:"javascript/avanzado",slug:"/javascript/avanzado/programacion-funcional",permalink:"/docs/javascript/avanzado/programacion-funcional",draft:!1,editUrl:"https://github.com/makeitrealcamp/new-guides/tree/main/docs/javascript/avanzado/programacion-funcional.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Uso del this (call, apply, bind)",permalink:"/docs/javascript/avanzado/uso-this"},next:{title:"Scope, hoisting, closures",permalink:"/docs/javascript/avanzado/scope-hoisting-closures"}},s={},c=[{value:"Funciones nombradas vs an\xf3nimas",id:"funciones-nombradas-vs-an\xf3nimas",level:2},{value:"Funciones que reciben funciones",id:"funciones-que-reciben-funciones",level:2},{value:"Map",id:"map",level:3},{value:"Reduce",id:"reduce",level:3},{value:"Funciones que retornan funciones",id:"funciones-que-retornan-funciones",level:2},{value:"Funciones puras",id:"funciones-puras",level:2},{value:"Inmutabilidad",id:"inmutabilidad",level:2}],p={toc:c},u="wrapper";function m(e){let{components:a,...n}=e;return(0,o.kt)(u,(0,r.Z)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"programaci\xf3n-funcional"},"Programaci\xf3n funcional"),(0,o.kt)("p",null,"La ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n funcional")," es un ",(0,o.kt)("strong",{parentName:"p"},"paradigma de la programaci\xf3n")," en donde las funciones se convierten en las protaginistas del c\xf3digo que escribimos."),(0,o.kt)("p",null,"Un ",(0,o.kt)("strong",{parentName:"p"},"paradigma de la programaci\xf3n")," es una forma de pensar en programaci\xf3n. Otros ",(0,o.kt)("strong",{parentName:"p"},"paradigmas de la programaci\xf3n")," incluyen la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n imperativa")," ","(","de la que vamos a hablar en un momento",")"," y la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n orientada por objetos"),". Estos paradigmas no son excluyentes y se pueden mezclar."),(0,o.kt)("p",null,"Aunque JavaScript no es un lenguaje puramente funcional, s\xed es posible programar de forma funcional. En JavaScript las funciones tienen las siguientes caracter\xedsticas:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Se pueden asignar a variables."),(0,o.kt)("li",{parentName:"ul"},"Se pueden pasar como par\xe1metro de otras funciones ","(",(0,o.kt)("strong",{parentName:"li"},"callbacks"),")","."),(0,o.kt)("li",{parentName:"ul"},"Se pueden retornar desde otras funciones.")),(0,o.kt)("h2",{id:"funciones-nombradas-vs-an\xf3nimas"},"Funciones nombradas vs an\xf3nimas"),(0,o.kt)("p",null,"En JavaScript las funciones pueden tener un nombre o ser an\xf3nimas:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// esta es una funci\xf3n nombrada\nfunction namedFn() {}\n\n// esta es una funci\xf3n an\xf3nima que estamos almacenando en una variable\nconst anonymousFn = function() {}\n")),(0,o.kt)("p",null,"Las funciones nombradas son aquellas que tienen un nombre entre la palabra ",(0,o.kt)("inlineCode",{parentName:"p"},"function")," y los par\xe9ntesis (",(0,o.kt)("inlineCode",{parentName:"p"},"()"),"). Las funciones nombradas se mueven al principio del ",(0,o.kt)("a",{parentName:"p",href:"scope-hoisting-closures#scope"},"scope"),", a esto se le conoce como ",(0,o.kt)("a",{parentName:"p",href:"scope-hoisting-closures#hoisting"},"hoisting"),"."),(0,o.kt)("p",null,"Las funciones an\xf3nimas se utilizan cuando queremos asignarlas a variables y, en algunas ocasiones, para pasarlas como par\xe1metros de otras funciones o retornarlas desde otra funci\xf3n."),(0,o.kt)("h2",{id:"funciones-que-reciben-funciones"},"Funciones que reciben funciones"),(0,o.kt)("p",null,"Un ",(0,o.kt)("strong",{parentName:"p"},"lenguaje funcional"),", a diferencia de un ",(0,o.kt)("strong",{parentName:"p"},"lenguaje imperativo"),", nos permite componer funciones para solucionar diferentes tipos de problemas. A estas funciones tambi\xe9n se les conoce como ",(0,o.kt)("strong",{parentName:"p"},"funciones de alto nivel")," (high order functions)."),(0,o.kt)("p",null,"Por ejemplo, imagina que tenemos el siguiente arreglo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const arr = [1, 2, 3];\n")),(0,o.kt)("p",null,"Ahora queremos imprimir todos sus elementos. En ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n imperativa")," lo har\xedamos de la siguiente forma:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"for (let i=0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n")),(0,o.kt)("p",null,"En programaci\xf3n funcional utilizar\xedamos una funci\xf3n llamada ",(0,o.kt)("inlineCode",{parentName:"p"},"forEach")," que viene inclu\xedda por defecto en todos los arreglos de JavaScript:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const sum = arr.forEach(elem => console.log(elem));\n")),(0,o.kt)("p",null,"M\xe1s compacto \xbfno?. Por debajo ",(0,o.kt)("inlineCode",{parentName:"p"},"forEach")," utiliza ",(0,o.kt)("inlineCode",{parentName:"p"},"for")," para hacer el recorrido de los elementos. No es que la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n funcional")," reemplace la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n imperativa"),", la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n funcional")," est\xe1 un nivel por encima de la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n imperativa"),"."),(0,o.kt)("h3",{id:"map"},"Map"),(0,o.kt)("p",null,"Otro m\xe9todo \xfatil que traen todos los arreglos en JavaScript es ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", que nos permite transformar cada uno de los elementos de un arreglo. Por ejemplo, imagina que queremos duplicar todos los valores de ",(0,o.kt)("inlineCode",{parentName:"p"},"arr"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const newArr = arr.map(elem => elem * 2);\n\n// newArr ser\xeda [2, 4, 6]\n")),(0,o.kt)("p",null,"Lo interesante de las funciones es que se pueden anidar para crear c\xf3digo muy sutil. Por ejemplo, el siguiente c\xf3digo duplicar\xeda cada elemento del arreglo y despu\xe9s imprimir\xeda cada elemento duplicado."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"arr\n  .map(elem => elem * 2)\n  .forEach(elem => console.log(elem));\n")),(0,o.kt)("p",null,"Separ\xe9 el c\xf3digo en varias l\xedneas para que sea m\xe1s f\xe1cil de leer. Esto es una buena pr\xe1ctica cuando se anidan funciones."),(0,o.kt)("h3",{id:"reduce"},"Reduce"),(0,o.kt)("p",null,"Otra operaci\xf3n muy \xfatil con los arreglos es convertirlos en algo completamente diferente, por ejemplo sumar todos los elementos, o crear un objeto a partir de un arreglo. A esto se le conoce en programaci\xf3n como ",(0,o.kt)("strong",{parentName:"p"},"reducirlos"),"."),(0,o.kt)("p",null,"En JavaScript todos los arreglos tienen un m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce")," que se utiliza precisamente para esto. Por ejemplo, si queremos sumar todos los elementos en ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," podemos hacer lo siguiente:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const sum = arr.reduce((acc, elem) => acc + elem);\nconsole.log(sum); // 6\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"reduce")," recibe un ",(0,o.kt)("strong",{parentName:"p"},"callback")," ","(","una funci\xf3n",")"," y, opcionalmente, un valor inicial. El ",(0,o.kt)("strong",{parentName:"p"},"callback")," recibe dos par\xe1metros: un acumulador y un elemento. Lo que retorne el ",(0,o.kt)("strong",{parentName:"p"},"callback")," se va a utilizar como el acumulador del siguiente elemento. En nuestro caso vamos acumulando la suma."),(0,o.kt)("p",null,"Tambi\xe9n podemos utilizar ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce")," para operaciones un poco m\xe1s complejas. Por ejemplo para contar cuantas veces se repite cada caracter en una cadena de texto:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const input = \"Make it real\"\nconst response = input.split('').reduce((acc, now) => {\n  acc[now] ? acc[now] ++ : acc[now] = 1;\n  return acc;\n}, {})\n\nconsole.log(response) // { M: 1, a: 2, k: 1, e: 2, ' ': 2, i: 1, t: 1, r: 1, l: 1 }\n")),(0,o.kt)("p",null,"El ",(0,o.kt)("inlineCode",{parentName:"p"},"split")," hace que la cadena se convierta en un arreglo que podemos utilizar para contar las letras (utilizando el ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce"),"). Al ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce")," le estamos pasando un objeto vac\xedo como valor inicial (l\xednea 5). En cada iteraci\xf3n del ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce")," verificamos si la letra existe como propiedad del objeto. Si existe, le sumamos 1 a esa propiedad, de lo contrario la creamos y le asignamos el valor 1. Por \xfaltimo retornamos el objeto actualizado."),(0,o.kt)("h2",{id:"funciones-que-retornan-funciones"},"Funciones que retornan funciones"),(0,o.kt)("p",null,"La capacidad de retornar una funci\xf3n de otra funci\xf3n es una caracter\xedstica fundamental de la ",(0,o.kt)("strong",{parentName:"p"},"programaci\xf3n funcional")," que nos permite crear soluciones reutilizables a problemas comunes."),(0,o.kt)("p",null,"Librer\xedas como ",(0,o.kt)("a",{parentName:"p",href:"https://lodash.com/"},"Lodash"),", ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React")," y ",(0,o.kt)("a",{parentName:"p",href:"https://redux.js.org/"},"Redux"),", entre muchas otras, hacen amplio uso de esta capacidad."),(0,o.kt)("p",null,"Veamos c\xf3mo crear y utilizar una funci\xf3n que retorne otra funci\xf3n:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'function hello(name) {\n  return function() {\n    console.log(`Hola ${name}`)\n  }\n}\n\nconst helloMaria = hello("Maria")\nhelloMaria() // "Hola Maria"\n\n// o m\xe1s compacto\nhello("Pedro")() // "Hola Pedro"\n')),(0,o.kt)("p",null,"La funci\xf3n ",(0,o.kt)("inlineCode",{parentName:"p"},"hello")," recibe un argumento (un nombre) y retorna una nueva funci\xf3n. En la l\xednea 7 estamos almacenando la funci\xf3n retornada en una variable llamada ",(0,o.kt)("inlineCode",{parentName:"p"},"helloMaria")," que despu\xe9s invocamos. Tambi\xe9n es posible evitarnos la asignaci\xf3n a una nueva variable e invocar la funci\xf3n retornada inmediatamente como lo hacemos en la l\xednea 11."),(0,o.kt)("p",null,"En la pr\xe1ctica es poco probable que necesites crear una funci\xf3n que retorne otra funci\xf3n, es m\xe1s com\xfan que las ",(0,o.kt)("strong",{parentName:"p"},"utilices")," en librer\xedas o incluso en el mismo lenguaje."),(0,o.kt)("p",null,"Por ejemplo, el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"bind")," (explicado en la gu\xeda ",(0,o.kt)("a",{parentName:"p",href:"uso-this"},"Uso del this"),") retorna otra funci\xf3n que garantiza que la funci\xf3n original siempre se ejecute en el contexto adecuado."),(0,o.kt)("p",null,"Otro ejemplo es el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"before")," de ",(0,o.kt)("a",{parentName:"p",href:"https://lodash.com/"},"Lodash")," que garantiza que una funci\xf3n no se llame m\xe1s de 1 vez:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// asumiendo que Lodash est\xe1 incluido\nconst calculate = _.once(function() {\n  // realiza un calculo complejo y retorna un resultado\n})\n\ncalculate()\ncalculate() // no ejecuta la funci\xf3n nuevamente, retorna el resultado anterior\n")),(0,o.kt)("p",null,"Aunque la funci\xf3n ",(0,o.kt)("inlineCode",{parentName:"p"},"once")," ya est\xe1 implementado en ",(0,o.kt)("a",{parentName:"p",href:"https://lodash.com/"},"Lodash")," podr\xedamos implementarla nosotros mismos:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function once(fn) {\n  let called = false\n  let result\n\n  return function() {\n    if (!called) {\n      called = true\n      result = fn()\n    }\n    return result\n  }\n}\n")),(0,o.kt)("p",null,"Primero definimos dos variables: ",(0,o.kt)("inlineCode",{parentName:"p"},"called")," que nos va a decir si la funci\xf3n ya se invoc\xf3 y ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," en donde vamos a almacenar el resultado de la funci\xf3n. Despu\xe9s retornamos una nueva funci\xf3n que hace todo el trabajo pesado: si la funci\xf3n no ha sido invocada la invoca, cambia ",(0,o.kt)("inlineCode",{parentName:"p"},"called")," a ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," y almacena el resultado en ",(0,o.kt)("inlineCode",{parentName:"p"},"result"),". Por \xfaltimo, en la l\xednea 10, retornamos el resultado."),(0,o.kt)("h2",{id:"funciones-puras"},"Funciones puras"),(0,o.kt)("p",null,"Las ",(0,o.kt)("strong",{parentName:"p"},"funciones puras")," son funciones que cumplen con las dos siguientes condiciones:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Retornan el mismo valor si se les pasan los mismos argumentos."),(0,o.kt)("li",{parentName:"ul"},"No tienen efectos secundarios (como imprimir en la console, escribir a la red o al disco, etc.).")),(0,o.kt)("p",null,"En la pr\xe1ctica no es posible crear una aplicaci\xf3n a partir de funciones puras \xfanicamente, pero es bueno saber qu\xe9 es y qu\xe9 no es una ",(0,o.kt)("strong",{parentName:"p"},"funci\xf3n pura"),"."),(0,o.kt)("p",null,"El principal beneficio de las funciones puras es que nos permiten escribir pruebas unitarias m\xe1s f\xe1cilmente."),(0,o.kt)("h2",{id:"inmutabilidad"},"Inmutabilidad"),(0,o.kt)("p",null,"Otro principio importante en la programaci\xf3n funcional es el de ",(0,o.kt)("strong",{parentName:"p"},"inmutabilidad"),", que dice que las variables, objetos y arreglos no se deber\xedan modificar una vez han sido creados. Eso implica utilizar siempre ",(0,o.kt)("inlineCode",{parentName:"p"},"const")," en el caso de variables y crear un nuevo arreglo u objeto cuando se necesite modificarlos."),(0,o.kt)("p",null,"En JavaScript todos los ",(0,o.kt)("em",{parentName:"p"},"strings")," son ",(0,o.kt)("strong",{parentName:"p"},"inmutables")," (no pueden ser modificados). Todos los m\xe9todos sobre los ",(0,o.kt)("em",{parentName:"p"},"strings")," devuelven nuevos ",(0,o.kt)("em",{parentName:"p"},"strings"),". Por ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const str = "Este string es inmutable"\nconst str2 = str.slice(5, 11)\nconst str3 = str2.toUpperCase()\n\nconsole.log(str) // "Este string es inmutable"\nconsole.log(str2) // "string"\nconsole.log(str3) // "STRING"\n')),(0,o.kt)("p",null,"Lo m\xe1s importante de este ejemplo es que ",(0,o.kt)("inlineCode",{parentName:"p"},"str")," nunca cambia, los m\xe9todos ",(0,o.kt)("inlineCode",{parentName:"p"},"slice")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"toUpperCase")," retornan nuevos ",(0,o.kt)("em",{parentName:"p"},"strings"),"."),(0,o.kt)("p",null,"Los arreglos y objetos, por otro lado, son ",(0,o.kt)("strong",{parentName:"p"},"mutables")," (se pueden modificar)."),(0,o.kt)("p",null,"Los arreglos tienen algunos m\xe9todos que ",(0,o.kt)("strong",{parentName:"p"},"mutan")," (modifican) el arreglo (p.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"push"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"shift")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"splice"),") y otros que retornan un nuevo arreglo (p.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"concat"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"filter"),")."),(0,o.kt)("p",null,"Para modificar un arreglo de forma ",(0,o.kt)("strong",{parentName:"p"},"inmutable")," se recomienda crear un nuevo objeto:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const obj = { a: 1, b: 2, c: 3 }\nconst newObj = { ...obj, c: 4, d: 5}\n// newObj queda { a: 1, b: 2, c: 4, d: 5}\n")),(0,o.kt)("p",null,"La ventaja principal de la ",(0,o.kt)("strong",{parentName:"p"},"inmutabilidad")," es que permite crear programas que son m\xe1s f\xe1cil de entender y mantener. En programas peque\xf1os esto no es muy relevante, pero a medida que los programas crecen se vuelve m\xe1s importante."))}m.isMDXComponent=!0}}]);