"use strict";(self.webpackChunkmir_guia=self.webpackChunkmir_guia||[]).push([[6130],{3905:(e,n,a)=>{a.d(n,{Zo:()=>d,kt:()=>f});var t=a(7294);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){o(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},d=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(a),m=o,f=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return a?t.createElement(f,l(l({ref:n},d),{},{components:a})):t.createElement(f,l({ref:n},d))}));function f(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=a.length,l=new Array(r);l[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[c]="string"==typeof e?e:o,l[1]=i;for(var p=2;p<r;p++)l[p]=a[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9307:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var t=a(7462),o=(a(7294),a(3905));const r={},l="Uso del this (call, apply, bind)",i={unversionedId:"javascript/avanzado/uso-this",id:"javascript/avanzado/uso-this",title:"Uso del this (call, apply, bind)",description:"this es una palabra clave en JavaScript que se utiliza para referirnos a las propiedades de un objeto. Por ejemplo:",source:"@site/docs/javascript/avanzado/uso-this.md",sourceDirName:"javascript/avanzado",slug:"/javascript/avanzado/uso-this",permalink:"/docs/javascript/avanzado/uso-this",draft:!1,editUrl:"https://github.com/makeitrealcamp/new-guides/tree/main/docs/javascript/avanzado/uso-this.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"ES6",permalink:"/docs/javascript/avanzado/es6"},next:{title:"Programaci\xf3n funcional",permalink:"/docs/javascript/avanzado/programacion-funcional"}},s={},p=[{value:"Diferentes contextos para <code>this</code>",id:"diferentes-contextos-para-this",level:2},{value:"<code>call</code> y <code>apply</code>",id:"call-y-apply",level:2},{value:"<code>bind</code>",id:"bind",level:2},{value:"Funciones flecha",id:"funciones-flecha",level:2}],d={toc:p},c="wrapper";function u(e){let{components:n,...a}=e;return(0,o.kt)(c,(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"uso-del-this-call-apply-bind"},"Uso del this (call, apply, bind)"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"this")," es una palabra clave en JavaScript que se utiliza para referirnos a las propiedades de un objeto. Por ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const person = {\n  name: "Pedro",\n  greet() {\n    console.log(`Hola ${this.name}`)\n  }\n}\n')),(0,o.kt)("p",null,"La \xfanica forma de referirnos a la propiedad ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," desde el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"greet")," es utilizando la palabra clave ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'person.greet() // "Hola Pedro"\n')),(0,o.kt)("h2",{id:"diferentes-contextos-para-this"},"Diferentes contextos para ",(0,o.kt)("inlineCode",{parentName:"h2"},"this")),(0,o.kt)("p",null,"El problema con ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," es que las funciones en JavaScript se pueden mover de un lado a otro: se pueden asignar a variables, pasar como argumento de otra funci\xf3n y retornar desde otra funci\xf3n. La pregunta es qu\xe9 le pasa a ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," cuando ocurre todo este movimiento."),(0,o.kt)("p",null,"Por ejemplo, \xbfqu\xe9 pasa si asignamos el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"greet")," del objeto ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," (ejemplo anterior) a una nueva variable ",(0,o.kt)("inlineCode",{parentName:"p"},"hello"),"?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const hello = person.greet\nhello() // "Hola undefined"\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"En JavaScript, ",(0,o.kt)("inlineCode",{parentName:"strong"},"this")," cambia seg\xfan el lugar desde el que se invoque:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Si se invoca sobre el m\xe9todo de un objeto, ",(0,o.kt)("inlineCode",{parentName:"li"},"this")," se refiere a las propiedades del objeto (el caso normal)."),(0,o.kt)("li",{parentName:"ul"},"Si se invoca afuera de un objeto, ",(0,o.kt)("inlineCode",{parentName:"li"},"this")," se refiere al contexto global (el objeto ",(0,o.kt)("inlineCode",{parentName:"li"},"window")," en un navegador o ",(0,o.kt)("inlineCode",{parentName:"li"},"undefined")," en Node.js)."),(0,o.kt)("li",{parentName:"ul"},"Si se invoca sobre una funci\xf3n constructora, ",(0,o.kt)("inlineCode",{parentName:"li"},"this")," se refiere al nuevo objeto creado.")),(0,o.kt)("p",null,"Hay otra forma de cambiar el contexto de ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," y es con los m\xe9todos ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"apply"),"."),(0,o.kt)("h2",{id:"call-y-apply"},(0,o.kt)("inlineCode",{parentName:"h2"},"call")," y ",(0,o.kt)("inlineCode",{parentName:"h2"},"apply")),(0,o.kt)("p",null,"Estos dos m\xe9todos nos permiten cambiar el contexto del ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," al invocar una funci\xf3n. Por ejemplo, imagina que tenemos una funci\xf3n llamada ",(0,o.kt)("inlineCode",{parentName:"p"},"greet")," que utiliza ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," internamente, podemos utilizar ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," para cambiar el contexto de ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," al invocarla:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const greet = function() {\n  console.log(`Hola ${this.name}`)\n}\n\nconst pedro = { name: "Pedro" }\ngreet.call(pedro) // "Hola Pedro"\n\nconst maria = { name: "Maria" }\ngreet.call(maria) // "Hola Maria"\n')),(0,o.kt)("p",null,"La diferencia entre ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," es la forma en que se pasan los argumentos de la funci\xf3n: ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," recibe los argumentos como un arreglo, mientras que ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," los recibe como argumentos independientes. Por ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const sum = function(a, b) {\n  console.log(`${this.name}, el resultado es ${a + b}`)\n}\n\nconst pedro = { name: "Pedro" }\nsum.call(pedro, 1, 2) // "Pedro, el resultado es 3"\nsum.apply(pedro, [1, 2]) // "Pedro, el resultado es 3"\n')),(0,o.kt)("h2",{id:"bind"},(0,o.kt)("inlineCode",{parentName:"h2"},"bind")),(0,o.kt)("p",null,"Con el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"bind")," podemos garantizar que un m\xe9todo siempre se invoque en un contexto espec\xedfico. Por ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'let greet = function() {\n  console.log(`Hola ${this.name}`)\n}\n\nconst pedro = { name: "Pedro" }\ngreet = greet.bind(pedro); // sobrescribimos la variable\n\ngreet() // "Hola Pedro"\n')),(0,o.kt)("p",null,"El m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"bind")," devuelve una nueva funci\xf3n que encapsula a la original para garantizar que siempre se ejecute con el contexto que queremos. En este ejemplo estamos sobrescribiendo la variable ",(0,o.kt)("inlineCode",{parentName:"p"},"greet")," pero hubi\xe9semos podido asignarla a una variable diferente."),(0,o.kt)("h2",{id:"funciones-flecha"},"Funciones flecha"),(0,o.kt)("p",null,"Las funciones flecha, a diferencia de las funciones normales, mantienen siempre el contexto de ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," enlazado al lugar donde son defininidas, independiente de c\xf3mo se llamen. Veamos un ejemplo."),(0,o.kt)("p",null,"Podemos modificar el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"greet")," para que imprima el saludo despu\xe9s de 1 segundo utilizando la funci\xf3n ",(0,o.kt)("inlineCode",{parentName:"p"},"setTimeout"),", que nos permite ejecutar una funci\xf3n despu\xe9s del tiempo que le digamos:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const person = {\n  name: "Pedro",\n  greet() {\n    setTimeout(function() {\n      console.log(`Hola ${this.name}`)\n    }, 1000)\n  }\n}\n')),(0,o.kt)("p",null,"El problema es que si ahora ejecutamos el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"greet")," obtendremos un resultado inesperado:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'person.greet();\n// despu\xe9s de 1 segundo imprime "Hola undefined"\n')),(0,o.kt)("p",null,"La raz\xf3n es que internamente ",(0,o.kt)("inlineCode",{parentName:"p"},"setTimeout")," invoca la funci\xf3n desde el contexto global y por lo tanto la referencia original de ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," se pierde."),(0,o.kt)("p",null,"Cuando no exist\xedan las funciones flecha, la \xfanica soluci\xf3n era asignar ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," a una variable con otro nombre:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"greet() {\n  const self = this; // guardamos this en otra variable self\n  setTimeout(function() {\n    console.log(`Hola ${self.name}`) // utilizamos self en vez de this\n  }, 1000)\n}\n")),(0,o.kt)("p",null,"Hoy podemos utilizar funciones flecha que mantienen el contexto de ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," enlazado al lugar donde se defini\xf3:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"greet() {\n  setTimeout(() => { // funci\xf3n flecha\n    console.log(`Hola ${this.name}`)\n  }, 1000)\n}\n")),(0,o.kt)("p",null,"En este caso la funci\xf3n flecha se defini\xf3 dentro del m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"greet"),", cuyo contexto es el objeto ",(0,o.kt)("inlineCode",{parentName:"p"},"person"),"."))}u.isMDXComponent=!0}}]);