"use strict";(self.webpackChunkmir_guia=self.webpackChunkmir_guia||[]).push([[6638],{3905:(e,a,n)=>{n.d(a,{Zo:()=>u,kt:()=>g});var o=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function t(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);a&&(o=o.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?t(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,o,r=function(e,a){if(null==e)return{};var n,o,r={},t=Object.keys(e);for(o=0;o<t.length;o++)n=t[o],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(o=0;o<t.length;o++)n=t[o],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=o.createContext({}),c=function(e){var a=o.useContext(i),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},u=function(e){var a=c(e.components);return o.createElement(i.Provider,{value:a},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return o.createElement(o.Fragment,{},a)}},m=o.forwardRef((function(e,a){var n=e.components,r=e.mdxType,t=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,g=d["".concat(i,".").concat(m)]||d[m]||p[m]||t;return n?o.createElement(g,s(s({ref:a},u),{},{components:n})):o.createElement(g,s({ref:a},u))}));function g(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var t=n.length,s=new Array(t);s[0]=m;var l={};for(var i in a)hasOwnProperty.call(a,i)&&(l[i]=a[i]);l.originalType=e,l[d]="string"==typeof e?e:r,s[1]=l;for(var c=2;c<t;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4627:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var o=n(7462),r=(n(7294),n(3905));const t={},s="Estructuras de datos",l={unversionedId:"algoritmos/estructuras-de-datos",id:"algoritmos/estructuras-de-datos",title:"Estructuras de datos",description:"Las estructuras de datos nos permite almacenar y manipular informaci\xf3n compleja compuesta de datos b\xe1sicos (n\xfameros, booleanos, caracteres, etc.) y otras estructuras de datos en nuestros programas y algoritmos.",source:"@site/docs/algoritmos/estructuras-de-datos.md",sourceDirName:"algoritmos",slug:"/algoritmos/estructuras-de-datos",permalink:"/docs/algoritmos/estructuras-de-datos",draft:!1,editUrl:"https://github.com/makeitrealcamp/new-guides/tree/main/docs/algoritmos/estructuras-de-datos.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Complejidad de un algoritmo (notaci\xf3n Big-O)",permalink:"/docs/algoritmos/complejidad"},next:{title:"Recursi\xf3n",permalink:"/docs/algoritmos/recursion"}},i={},c=[{value:"Arreglos",id:"arreglos",level:2},{value:"Diccionarios",id:"diccionarios",level:2},{value:"Listas encadenadas",id:"listas-encadenadas",level:2},{value:"Colas (queues)",id:"colas-queues",level:2},{value:"\xc1rboles",id:"\xe1rboles",level:2},{value:"Ejercicio",id:"ejercicio",level:3},{value:"Grafos",id:"grafos",level:2},{value:"Listas de adyacencia",id:"listas-de-adyacencia",level:3},{value:"Matrices de adyacencia",id:"matrices-de-adyacencia",level:3},{value:"Nodos interconectados",id:"nodos-interconectados",level:3},{value:"Conjuntos (sets)",id:"conjuntos-sets",level:2}],u={toc:c},d="wrapper";function p(e){let{components:a,...n}=e;return(0,r.kt)(d,(0,o.Z)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"estructuras-de-datos"},"Estructuras de datos"),(0,r.kt)("p",null,"Las estructuras de datos nos permite almacenar y manipular informaci\xf3n compleja compuesta de datos b\xe1sicos (n\xfameros, booleanos, caracteres, etc.) y otras estructuras de datos en nuestros programas y algoritmos."),(0,r.kt)("h2",{id:"arreglos"},"Arreglos"),(0,r.kt)("p",null,"Seguramente ya conoces los arreglos pero es importante saber que existen dos tipos de arreglos: est\xe1ticos y din\xe1micos."),(0,r.kt)("p",null,"Los arreglos est\xe1ticos tienen una longitud fija mientras que los din\xe1micos tienen una longitud variable. En C, C++ y Java, entre otros, los arreglos son est\xe1ticos mientras que en JavaScript, Ruby y Python, entre otros, son din\xe1micos."),(0,r.kt)("p",null,"Los arreglos din\xe1micos son mucho m\xe1s flexibles pero pueden llegar a ser lentos u ocupar m\xe1s espacio en memoria (recuerda que JavaScript y Ruby est\xe1n escritos en lenguajes de m\xe1s bajo nivel como C o C++ que no soportan arreglos din\xe1micos)."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.quora.com/What-is-the-underlying-data-structure-of-a-javascript-Array"},"Este enlace")," explica c\xf3mo est\xe1n implementados los arreglos de JavaScript."),(0,r.kt)("h2",{id:"diccionarios"},"Diccionarios"),(0,r.kt)("p",null,"Los diccionarios est\xe1n compuestos de llaves y valores. La principal caracter\xedstica de un diccionario es que la b\xfasqueda de un elemento por llave es constante ",(0,r.kt)("inlineCode",{parentName:"p"},"O(1)"),"."),(0,r.kt)("p",null,"La mayor\xeda de lenguajes incluyen diccionarios. En Ruby se llaman hashes, en JavaScript objetos y en Python diccionarios."),(0,r.kt)("h2",{id:"listas-encadenadas"},"Listas encadenadas"),(0,r.kt)("p",null,"Las listas encadenadas son similares a los arreglos, en el sentido que son una lista de elementos, pero la implementaci\xf3n es diferente."),(0,r.kt)("p",null,"Una lista encadenada est\xe1 compuesta de nodos. Cada nodo tiene un valor y una referencia al siguiente nodo como se muestra en la siguiente imagen:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://s3.amazonaws.com/makeitreal/images/full-stack-curriculum/linked-list.png",alt:"Lista encadenada"})),(0,r.kt)("p",null,"La ventaja principal de una lista encadenada (sobre un arreglo) es que insertar elementos en la mitad de la lista es muy f\xe1cil (s\xf3lo se deben cambiar las referencias de los nodos). Sin embargo, la desventaja es que no se puede acceder a una posici\xf3n aleatoria (toca recorrer la lista hasta llegar a la posici\xf3n)."),(0,r.kt)("p",null,"La lista tambi\xe9n puede estar doblemente encadenada, es decir, cada nodo tiene una referencia al siguiente y al anterior."),(0,r.kt)("p",null,"Las operaciones principales de una lista encadenada son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Insertar un valor en una posici\xf3n (por defecto al final)."),(0,r.kt)("li",{parentName:"ul"},"Obtener un valor por posici\xf3n."),(0,r.kt)("li",{parentName:"ul"},"Recorrer las posiciones."),(0,r.kt)("li",{parentName:"ul"},"Eliminar una posici\xf3n.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const list = new LinkedList();\nlist.add('a');\nlist.add('b');\nlist.add('d');\nlist.addAt(2, 'c');\n\nlist.valueAt(0); // 'a'\n\nlist.forEach((val, i) => {\n  console.log(`Value at position ${i}: ${val}`);\n});\n\nlist.removeAt(0);\n")),(0,r.kt)("p",null,"La operaci\xf3n ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," es ",(0,r.kt)("inlineCode",{parentName:"p"},"O(n)")," aunque se puede mantener una referencia interna al \xfaltimo nodo de la lista y se convertir\xeda en ",(0,r.kt)("inlineCode",{parentName:"p"},"O(1)"),"."),(0,r.kt)("p",null,"Las operaciones ",(0,r.kt)("inlineCode",{parentName:"p"},"addAt"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"valueAt")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"removeAt")," son ",(0,r.kt)("inlineCode",{parentName:"p"},"O(n)")," porque toca recorrer la lista hasta llegar a la posici\xf3n deseada."),(0,r.kt)("p",null,"En la vida real las listas encadenadas ",(0,r.kt)("strong",{parentName:"p"},"no")," son muy comunes (los arreglos funcionan bien en la mayor\xeda de los casos) pero igual es importante saber que existen y es un buen ejercicio hacer la implementaci\xf3n."),(0,r.kt)("h2",{id:"colas-queues"},"Colas (queues)"),(0,r.kt)("p",null,"Una cola es una estructura que permite agregar elementos al final de la lista y obtener el primero (como una fila de pago en un supermercado). A esto se le conoce como PEPS (primero en entrar, primero en salir)."),(0,r.kt)("p",null,"Las operaciones principales de una cola son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Agregar un valor."),(0,r.kt)("li",{parentName:"ul"},"Obtener el primer valor."),(0,r.kt)("li",{parentName:"ul"},"Obtener el tama\xf1o.")),(0,r.kt)("p",null,"Las colas se usan en programaci\xf3n principalmente para almacenar informaci\xf3n que va a ser procesada en el futuro."),(0,r.kt)("p",null,"Las colas se pueden implementar sobre un arreglo limitando las operaciones para que se comporte como una cola (p.e. no se debe poder obtener un elemento por posici\xf3n ni insertar en cualquier posici\xf3n)."),(0,r.kt)("p",null,"##\xa0Pilas (stacks)"),(0,r.kt)("p",null,"Una pila es una estructua que permite agregar elementos al inicio de una lista y obtener el primero (como una pila de libros en la que solo puedes tomar el libro de la parte superior, y en la que solo puedes ubicar libros encima de los dem\xe1s). A esto se le conoce como UEPS (\xfaltimo en entrar, primero en salir)."),(0,r.kt)("p",null,"Las operaciones principales de una pila son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Agregar un valor."),(0,r.kt)("li",{parentName:"ul"},"Obtener el \xfaltimo valor agregado."),(0,r.kt)("li",{parentName:"ul"},"Obtener el tama\xf1o.")),(0,r.kt)("p",null,"Las pilas se pueden implementar utilizando un arreglo y limitando las operaciones para que se comporte como una pila (p.e. no se debe poder obtener un elemento por posici\xf3n ni insertar en cualquier posici\xf3n)."),(0,r.kt)("h2",{id:"\xe1rboles"},"\xc1rboles"),(0,r.kt)("p",null,"Los \xe1rboles est\xe1n compuestos de nodos como las listas encadenadas. Sin embargo, un \xe1rbol tiene un nodo ra\xedz con referencia a cero o m\xe1s nodos hijos. Estos nodos, a su vez, tienen referencias a otros nodos hijos, y as\xed sucesivamente."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://s3.amazonaws.com/makeitreal/images/full-stack-curriculum/tree.png",alt:"\xc1rbol"})),(0,r.kt)("p",null,"A los nodos que no tienen hijos se le conoce como un nodo hoja."),(0,r.kt)("p",null,"Un \xe1rbol en el que cada nodo puede tener m\xe1ximo dos hijos se le conoce como un ",(0,r.kt)("strong",{parentName:"p"},"\xe1rbol binario"),"."),(0,r.kt)("p",null,"Un \xe1rbol puede ser ordenado o desordenado."),(0,r.kt)("p",null,"En la vida real los \xe1rboles se utilizan para representar jerarqu\xedas (p.e. las posiciones en una empresa, los elementos en HTML, etc.) y optimizar b\xfasquedas."),(0,r.kt)("p",null,"La forma m\xe1s f\xe1cil de implementar un \xe1rbol es utilizando nodos interconectados, similar a como se implementan las listas encadenadas. La diferencia es que la lista encadenada s\xf3lo tiene una referencia a otro nodo mientras que los \xe1rboles pueden tener varias referencias a otros nodos."),(0,r.kt)("p",null,"Las operaciones m\xe1s importantes de un \xe1rbol son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Insertar un nodo (dependiendo del tipo de \xe1rbol la ubicaci\xf3n puede ser asignada autom\xe1tica o manualmente)."),(0,r.kt)("li",{parentName:"ul"},"Remover un nodo"),(0,r.kt)("li",{parentName:"ul"},"Recorrer el \xe1rbol")),(0,r.kt)("p",null,"Existen dos formas de recorrer un \xe1rbol. La primera es empezar por la ra\xedz y recorrer la rama izquierda. Una vez se ha recorrido toda esa rama se realiza el mismo proceso con las dem\xe1s ramas que se desprenden de la ra\xedz. A este proceso se le conoce como ",(0,r.kt)("strong",{parentName:"p"},"b\xfasqueda por profunidad"),", en ingl\xe9s Depth-First Search (DFS)."),(0,r.kt)("p",null,"La otra forma es ir imprimiendo nivel por nivel. Se inicia por la ra\xedz, despu\xe9s se imprimen todos los hijos de la ra\xedz. Despu\xe9s se imprimen todos los nietos y as\xed sucesivamente (por niveles). A este proceso se le conoce como ",(0,r.kt)("strong",{parentName:"p"},"b\xfasqueda en anchura"),", en ingl\xe9s Breadth-First Search (BFS)."),(0,r.kt)("h3",{id:"ejercicio"},"Ejercicio"),(0,r.kt)("p",null,"Implementar un \xe1rbol binario que vamos a utilizar de la siguiente forma:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const tree = new BinaryTree();\ntree.add(4);\ntree.add(2);\ntree.add(7);\ntree.add(1);\ntree.add(3);\n")),(0,r.kt)("p",null,"El \xe1rbol debe queda de la siguiente forma:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"     4\n   /   \\\n  2     7\n / \\\n1   3\n")),(0,r.kt)("p",null,"Adicionalmente al m\xe9todo ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," intenta implementar el m\xe9todo ",(0,r.kt)("inlineCode",{parentName:"p"},"traverseDFS")," (recorrido de profundidad) y ",(0,r.kt)("inlineCode",{parentName:"p"},"traverseBFS")," (recorrido de anchura) que reciben una funci\xf3n:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"tree.traverseDFS(function(e) { console.log(e); });\n// 4\n// 2\n// 1\n// 3\n// 7\n\ntree.traverseBFS(function(e) { console.log(e); });\n// 4\n// 2\n// 7\n// 1\n// 3\n")),(0,r.kt)("h2",{id:"grafos"},"Grafos"),(0,r.kt)("p",null,"Los grafos son ",(0,r.kt)("strong",{parentName:"p"},"nodos")," interconectados entre s\xed a trav\xe9s de ",(0,r.kt)("strong",{parentName:"p"},"conexiones"),"."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://s3.amazonaws.com/makeitreal/images/full-stack-curriculum/graph-directed.png",alt:"Grafo direccionado"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Nota:")," A los nodos se les conoce como ",(0,r.kt)("strong",{parentName:"p"},"v\xe9rtices")," y a las conexiones como ",(0,r.kt)("strong",{parentName:"p"},"aristas")," (en Ingl\xe9s ",(0,r.kt)("strong",{parentName:"p"},"edges"),")."),(0,r.kt)("p",null,"El grafo de la imagen est\xe1 direccionado, es decir, cada conexi\xf3n va en un solo sentido o direcci\xf3n. Un grafo tambi\xe9n puede ser doblemente direccionado (las conexiones van en ambos sentidos) como se muestra en la siguiente imagen:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://s3.amazonaws.com/makeitreal/images/full-stack-curriculum/graph-undirected.png",alt:"Grafo doblemente direccionado"})),(0,r.kt)("p",null,"Las ",(0,r.kt)("strong",{parentName:"p"},"conexiones")," pueden tener un peso (un valor) como se muestra en la siguiente imagen:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://s3.amazonaws.com/makeitreal/images/full-stack-curriculum/graph-edge-values.png",alt:"Grafo con pesos"})),(0,r.kt)("p",null,"Los gr\xe1fos pueden contener ciclos o ser ac\xedclico (sin ciclos)."),(0,r.kt)("p",null,"Existen muchas formas de implementar los grafos: lista de adyacencia, matriz de adyacencia o como una lista de nodos con referencia a otros nodos (similar a como se implementar\xeda una lista encadenada o un \xe1rbol). La implementaci\xf3n depende en gran parte del problema que se quiere solucionar."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Nota:")," Las listas encadenadas y los \xe1rboles son grafos con ciertas restricciones (p.e. una lista encadenada es un grafo ac\xedclico que tiene una cabeza y en donde cada nodo solo puede estar conectado a m\xe1ximo otro nodo)."),(0,r.kt)("h3",{id:"listas-de-adyacencia"},"Listas de adyacencia"),(0,r.kt)("p",null,"Se utiliza un diccionario en donde la llave representa el nodo y el valor es un arreglo que hace referencia a los otros nodos a los que est\xe1 conectado."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const graph = {\n  "A": ["C", "G"],\n  "B": ["A"],\n  "C": ["E"],\n  "D": ["A", "F"],\n  "E": [],\n  "F": [],\n  "G": ["E"]\n}\n')),(0,r.kt)("p",null,"Si las conexiones tienen un peso se puede agregar esta informaci\xf3n en la lista de adyacencia, por ejemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const graph = {\n  "A": [{ n: "C", p: 6 }, { n: "G", 3 }],\n  ...\n}\n')),(0,r.kt)("h3",{id:"matrices-de-adyacencia"},"Matrices de adyacencia"),(0,r.kt)("p",null,"Se utiliza una matriz (un arreglo de arreglos) para representar las relaciones en donde cada fila y columna representa un ",(0,r.kt)("strong",{parentName:"p"},"nodo"),". Las intersecciones representan las conexiones, se utiliza un ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," si no hay conexi\xf3n y un ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," si la hay."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const graph: [\n  [-1, 0, 1, 0, 0, 1, 0],\n  [1, -1, 0, 0, 0, 0, 0],\n  [0, 0, -1, 0, 1, 0, 0],\n  [1, 0, 0, -1, 0, 1, 0],\n  [0, 0, 0, 0, -1, 0, 0],\n  [0, 0, 0, 0, 1, -1, 0],\n  [0, 0, 0, 0, 0, 0, -1]\n];\n")),(0,r.kt)("p",null,"Si las conexiones tienen peso se puede utilizar el peso en vez de ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," para representar las conexiones."),(0,r.kt)("h3",{id:"nodos-interconectados"},"Nodos interconectados"),(0,r.kt)("p",null,"Se utiliza una estructura de datos adicional que tiene un nombre (o un valor) y un arreglo de referencia a otros nodos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function Node(name, refs) {\n  this.name = name;\n  this.refs = refs;\n}\n\nconst a = new Node("A");\nconst b = new Node("B");\nconst c = new Node("C");\nconst d = new Node("D");\nconst e = new Node("E");\nconst f = new Node("F");\nconst g = new Node("F");\n\na.refs.push(c, g);\nb.refs.push(a);\nc.refs.push(e);\nd.refs.push(a, f);\ng.refs.push(e);\n')),(0,r.kt)("h2",{id:"conjuntos-sets"},"Conjuntos (sets)"),(0,r.kt)("p",null,"Un conjunto es una lista de elementos que ",(0,r.kt)("strong",{parentName:"p"},"no")," permite valores duplicados. La mayor\xeda de lenguajes de programaci\xf3n incluyen esta estructura de datos (p.e. JavaScript tiene el objeto ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"},"Set"),")."),(0,r.kt)("p",null,"Las operaciones principales de un conjunto son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Agregar un valor"),(0,r.kt)("li",{parentName:"ul"},"Obtener el tama\xf1o del conjunto."),(0,r.kt)("li",{parentName:"ul"},"Verificar si existe un valor."),(0,r.kt)("li",{parentName:"ul"},"Eliminar un valor.")),(0,r.kt)("p",null,"En JavaScript podemos utilizar ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"},"Set")," de la siguiente forma."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const mySet = new Set();\nmySet.add(1); // Set [ 1 ]\nmySet.add(5); // Set [ 1, 5 ]\nmySet.add(5); // Set [ 1, 5 ]\n\nmySet.size; // 2\n\nmySet.has(1); // true\n\nmySet.delete(5); // removes 5 from the set\n")))}p.isMDXComponent=!0}}]);