"use strict";(self.webpackChunkmir_guia=self.webpackChunkmir_guia||[]).push([[1439],{3905:(e,a,n)=>{n.d(a,{Zo:()=>c,kt:()=>v});var r=n(7294);function o(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function t(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?t(Object(n),!0).forEach((function(a){o(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,r,o=function(e,a){if(null==e)return{};var n,r,o={},t=Object.keys(e);for(r=0;r<t.length;r++)n=t[r],a.indexOf(n)>=0||(o[n]=e[n]);return o}(e,a);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(r=0;r<t.length;r++)n=t[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=r.createContext({}),p=function(e){var a=r.useContext(i),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},c=function(e){var a=p(e.components);return r.createElement(i.Provider,{value:a},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},m=r.forwardRef((function(e,a){var n=e.components,o=e.mdxType,t=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,v=u["".concat(i,".").concat(m)]||u[m]||d[m]||t;return n?r.createElement(v,l(l({ref:a},c),{},{components:n})):r.createElement(v,l({ref:a},c))}));function v(e,a){var n=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var t=n.length,l=new Array(t);l[0]=m;var s={};for(var i in a)hasOwnProperty.call(a,i)&&(s[i]=a[i]);s.originalType=e,s[u]="string"==typeof e?e:o,l[1]=s;for(var p=2;p<t;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4472:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>s,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const t={},l="ES6",s={unversionedId:"javascript/avanzado/es6",id:"javascript/avanzado/es6",title:"ES6",description:"ECMAScript es el est\xe1ndar sobre el que se basa JavaScript. Desde el 2015 se empezaron a realizar lanzamientos anuales con nuevas caracter\xedsticas para el lenguaje.",source:"@site/docs/javascript/avanzado/es6.md",sourceDirName:"javascript/avanzado",slug:"/javascript/avanzado/es6",permalink:"/docs/javascript/avanzado/es6",draft:!1,editUrl:"https://github.com/makeitrealcamp/new-guides/tree/main/docs/javascript/avanzado/es6.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Librer\xedas \\(Node.js\\)",permalink:"/docs/javascript/avanzado/librerias-node.js"},next:{title:"Uso del this (call, apply, bind)",permalink:"/docs/javascript/avanzado/uso-this"}},i={},p=[{value:"Soporte",id:"soporte",level:2},{value:"Nuevas formas de definir variables",id:"nuevas-formas-de-definir-variables",level:2},{value:"Funciones flecha",id:"funciones-flecha",level:2},{value:"Par\xe1metros por defecto",id:"par\xe1metros-por-defecto",level:2},{value:"Plantillas literales",id:"plantillas-literales",level:2},{value:"Destructuraci\xf3n",id:"destructuraci\xf3n",level:2},{value:"Los tres puntos (<code>...</code>)",id:"los-tres-puntos-",level:2},{value:"M\xe9todos concisos",id:"m\xe9todos-concisos",level:2},{value:"Incializaci\xf3n de objetos",id:"incializaci\xf3n-de-objetos",level:2},{value:"Clases",id:"clases",level:2},{value:"Herencia",id:"herencia",level:3},{value:"M\xf3dulos",id:"m\xf3dulos",level:2},{value:"Definiendo un m\xf3dulo",id:"definiendo-un-m\xf3dulo",level:3},{value:"Importando un m\xf3dulo",id:"importando-un-m\xf3dulo",level:3},{value:"Exportando valores por defecto",id:"exportando-valores-por-defecto",level:3}],c={toc:p},u="wrapper";function d(e){let{components:a,...n}=e;return(0,o.kt)(u,(0,r.Z)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"es6"},"ES6"),(0,o.kt)("p",null,"ECMAScript es el est\xe1ndar sobre el que se basa JavaScript. Desde el 2015 se empezaron a realizar lanzamientos anuales con nuevas caracter\xedsticas para el lenguaje."),(0,o.kt)("p",null,"ECMAScript 2015 ","(","ES6",")"," fue lanzado en 2015, ECMAScript 2016 ","(","ES7",")"," en el 2016, y as\xed sucesivamente. Es desafortunado que tengamos dos nombramientos pero, ni modo, as\xed es la vida. Tambi\xe9n vas a escuchar de ",(0,o.kt)("strong",{parentName:"p"},"ESNEXT"),", que son todos los cambios que se vienen en los pr\xf3ximos a\xf1os para JavaScript, y que Node.js y algunos navegadores ya empiezan a soportar."),(0,o.kt)("h2",{id:"soporte"},"Soporte"),(0,o.kt)("p",null,"Node.js soporta ES6 e incluso nuevas caracter\xedsticas de ES7 y ESNEXT en las versiones m\xe1s recientes."),(0,o.kt)("p",null,"Aunque algunos navegadores como Chrome y Firefox soportan ES6 desde hace alg\xfan tiempo, nuestra recomendaci\xf3n es que utilices ",(0,o.kt)("a",{parentName:"p",href:"https://babeljs.io/"},"Babel")," para transformar tu c\xf3digo para el front a ",(0,o.kt)("strong",{parentName:"p"},"ES5"),", que tiene mayor adopci\xf3n."),(0,o.kt)("h2",{id:"nuevas-formas-de-definir-variables"},"Nuevas formas de definir variables"),(0,o.kt)("p",null,"Adem\xe1s de ",(0,o.kt)("inlineCode",{parentName:"p"},"var"),", ahora existen dos formas m\xe1s de definir variables en JavaScript: ",(0,o.kt)("inlineCode",{parentName:"p"},"let")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"const"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"const")," s\xf3lo permite asignar el valor de una variable una \xfanica vez. Si intentas reasignarla se genera un error. Por ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const x = 5;\nx = 6; // se genera un error\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"let")," es similar a ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," pero con dos diferencias. La primera es que la \xfanica forma de limitar el alcance de una variable declarada con ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," es dentro de una funci\xf3n. En cambio, una variable declarada con ",(0,o.kt)("inlineCode",{parentName:"p"},"let")," tiene un alcance de bloque ","(","p.e. un ",(0,o.kt)("inlineCode",{parentName:"p"},"if"),", un ",(0,o.kt)("inlineCode",{parentName:"p"},"for")," o una funci\xf3n",")","."),(0,o.kt)("p",null,"Un bloque est\xe1 delimitado por corchetes ","(",(0,o.kt)("inlineCode",{parentName:"p"},"{")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"}"),")","."),(0,o.kt)("p",null,"Veamos un ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"if (true) {\n  var x = 5\n  let y = 6;\n}\n\nconsole.log(x); // 5\nconsole.log(y); // undefined\n")),(0,o.kt)("p",null,"Aunque la variable ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),", declarada con ",(0,o.kt)("inlineCode",{parentName:"p"},"var"),", fue creada dentro del ",(0,o.kt)("inlineCode",{parentName:"p"},"if"),", sigue existiendo fuera del ",(0,o.kt)("inlineCode",{parentName:"p"},"if"),". En cambio, la variable ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),", declarada con ",(0,o.kt)("inlineCode",{parentName:"p"},"let"),", s\xf3lo existe dentro del ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," ","(","dentro del bloque",")","."),(0,o.kt)("p",null,"Veamos otro ejemplo. Con ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," tenemos el siguiente problema cuando utilizamos un ",(0,o.kt)("inlineCode",{parentName:"p"},"for"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"for (var i = 0; i < 10; i++) {\n    process(items[i]);\n}\n\n// i sigue existiendo ac\xe1\nconsole.log(i); // 10\n")),(0,o.kt)("p",null,"En cambio, con ",(0,o.kt)("inlineCode",{parentName:"p"},"let")," ya no tenemos ese problema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"for (let i = 0; i < 10; i++) {\n    process(items[i]);\n}\n\nconsole.log(i); // error, la variable no existe\n")),(0,o.kt)("p",null,"La segunda diferencia entre ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"let")," es que si intentas volver a definir una variable con ",(0,o.kt)("inlineCode",{parentName:"p"},"let")," ocurre un error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var x = 5;\nvar x = 6; // no sale error\n\nlet y = 5;\nlet y = 6; // error!\n")),(0,o.kt)("p",null,"En general trata de declarar las variables con ",(0,o.kt)("inlineCode",{parentName:"p"},"const")," en tus programas. Si no es posible, utiliza ",(0,o.kt)("inlineCode",{parentName:"p"},"let"),"."),(0,o.kt)("p",null,"Una aclaraci\xf3n es que si defines un arreglo ","(","o un objeto",")"," con ",(0,o.kt)("inlineCode",{parentName:"p"},"const")," puedes modificarlo, lo que no se puede hacer es reasignar la variable con otro valor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const arr = [];\narr.push(1); // no hay problema\n\narr = 5; // error! const no permite reasignaci\xf3n\n")),(0,o.kt)("h2",{id:"funciones-flecha"},"Funciones flecha"),(0,o.kt)("p",null,"Ahora existe una nueva forma de definir funciones utilizando la notaci\xf3n ",(0,o.kt)("inlineCode",{parentName:"p"},"=>"),". Veamos un ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const hola = () => {\n  return "Hola!";\n}\n')),(0,o.kt)("p",null,"Si el cuerpo s\xf3lo tiene una l\xednea, se puede escribir de forma m\xe1s compacta a\xfan:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const hola = () => "Hola";\n')),(0,o.kt)("p",null,"F\xedjate que ni siquiera fue necesario escribir el ",(0,o.kt)("inlineCode",{parentName:"p"},"return"),"!"),(0,o.kt)("p",null,"Si la funci\xf3n recibe un \xfanico par\xe1metro se pueden omitir los par\xe9ntesis:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const hola = name => "Hola " + name;\n')),(0,o.kt)("h2",{id:"par\xe1metros-por-defecto"},"Par\xe1metros por defecto"),(0,o.kt)("p",null,"Ahora es posible asignar valores por defecto a los par\xe1metros de una funci\xf3n:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'var hola = (name = "Pedro") => "Hola " + name;\n\nconsole.log(hola()); // Hola Pedro\n')),(0,o.kt)("p",null,"Incluso es posible usar funciones y par\xe1metros anteriores:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'var getName = () => "Pedro";\nvar hola = (name=getName(), message="Hola " + name) => message;\n\nconsole.log(hola()); // Hola Pedro\n')),(0,o.kt)("p",null,"Este fue un ejemplo forzado para mostrar que es posible usar funciones como valor por defecto de un par\xe1metro y que, adem\xe1s, es posible utilizar, como valor de un par\xe1metro, el valor de otro par\xe1metro anterior."),(0,o.kt)("h2",{id:"plantillas-literales"},"Plantillas literales"),(0,o.kt)("p",null,"Existe una nueva forma de definir cadenas de texto que nos permite crear cadenas de varias l\xedneas, insertar expresiones de JavaScript y m\xe1s. Las plantillas literales se crean con tildes invertidas","(","`","`",")",":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"`una cadena`\n\n`una cadena\n de varias l\xedneas`\n\n`una cadena con expresi\xf3n ${1 + 1} de JavaScript`\n")),(0,o.kt)("h2",{id:"destructuraci\xf3n"},"Destructuraci\xf3n"),(0,o.kt)("p",null,"Destructuraci\xf3n es un atajo para asignar variables r\xe1pidamente a partir de un arreglo o un objeto. Veamos un ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const arr = [1, 2];\nconst [a, b] = arr; // ac\xe1 ocurre la destructuraci\xf3n\n\nconsole.log(a); // 1\nconsole.log(b); // 2\n")),(0,o.kt)("p",null,"Podemos hacer algo parecido a partir de un objeto:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const obj = { a: 1, b: 2 };\nconst { a, b } = obj; // ac\xe1 ocurre la destructuraci\xf3n\n\nconsole.log(a); // 1\nconsole.log(b); // 2\n")),(0,o.kt)("p",null,"Tambi\xe9n puedes usar destructuraci\xf3n en los par\xe1metros de una funci\xf3n:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const g = ({name: x}) => {\n  console.log(x);\n}\n\ng({name: 5});\n")),(0,o.kt)("h2",{id:"los-tres-puntos-"},"Los tres puntos (",(0,o.kt)("inlineCode",{parentName:"h2"},"..."),")"),(0,o.kt)("p",null,"Los tres puntos tienen dos significados en JavaScript. Por un lado se pueden utilizar para capturar los argumentos de una funci\xf3n. Por ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function restParams(param1, ...rest) {\n  console.log(param1) // imprime el valor del primer argumento\n  console.log(rest) // imprime los valores de los siguientes argumentos\n}\n")),(0,o.kt)("p",null,"A esto se e conoce como ",(0,o.kt)("strong",{parentName:"p"},"rest parameters")," (el resto de los par\xe1metros) y se reciben en un arreglo."),(0,o.kt)("p",null,"Por otro lado los tres puntos son el ",(0,o.kt)("strong",{parentName:"p"},"operador spread")," que permite separar o expandir un arreglo o un objeto para crear nuevos arreglos u objetos, o para pasar los valores de un arreglo como argumentos de una funci\xf3n."),(0,o.kt)("p",null,"Por ejemplo, el m\xe9todo ",(0,o.kt)("inlineCode",{parentName:"p"},"Math.max")," recibe varios n\xfameros por par\xe1metro y retorna el mayor. Sin embargo, si tenemos un arreglo, podemos utilizar el operador ",(0,o.kt)("inlineCode",{parentName:"p"},"spread")," para separarlos:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const nums = [1, 2, 3, 4]\n\nconst max = Math.max(...nums)\n// equivalente a Math.max(1, 2, 3, 4)\n")),(0,o.kt)("p",null,"Tambi\xe9n podemos utilizar el ",(0,o.kt)("strong",{parentName:"p"},"operador spread")," para crear arreglos a partir de otros arreglos:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const arr = [3, 4]\nconst newArr = [1, 2, ...arr, 5, 6] // [1, 2, 3, 4, 5, 6]\n")),(0,o.kt)("p",null,"Por \xfaltimo, podemos crear objetos a partir de otros objetos:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const obj = { a: 1, b: 2, c: 3 }\nconst newObj = { ...obj, c: 4, d: 5}\n// newObj queda { a: 1, b: 2, c: 4, d: 5}\n")),(0,o.kt)("h2",{id:"m\xe9todos-concisos"},"M\xe9todos concisos"),(0,o.kt)("p",null,"ES6 mejora la sintaxis para asignar m\xe9todos a objetos literales. Antes la forma en que se defin\xedan los m\xe9todos de un objeto era de la siguiente forma:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'var person = {\n  name: "Pedro",\n\n  sayName: function() {\n    console.log(this.name);\n  }\n}\n')),(0,o.kt)("p",null,"En ES6 puedes eliminar los dos puntos y la palabra ",(0,o.kt)("inlineCode",{parentName:"p"},"function")," de la siguiente forma:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const person = {\n  name: "Pedro",\n\n  sayName() {\n    console.log(this.name);\n  }\n}\n')),(0,o.kt)("h2",{id:"incializaci\xf3n-de-objetos"},"Incializaci\xf3n de objetos"),(0,o.kt)("p",null,"EN ES6 se introdujo una forma m\xe1s compacta para inicializar objetos literales:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const name = "Pedro";\nconst age = 20;\n\n// Antes\nvar obj = { name: name, age: age };\n\n// Ahora se puede escribir de forma m\xe1s compacta\nconst obj = { name, age };\n')),(0,o.kt)("h2",{id:"clases"},"Clases"),(0,o.kt)("p",null,"A diferencia de otros lenguajes orientados por objetos que utilizan clases para definir la jerarqu\xeda de objetos, JavaScript utiliza prototipos. Aunque muchos desarrolladores sienten que JavaScript no necesita clases, la gran cantidad de librer\xedas que simulaban clases en JavaScript llevaron a que se incluyeran directamente en el lenguaje."),(0,o.kt)("p",null,"Veamos un ejemplo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"class Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name)\n  }\n}\n")),(0,o.kt)("p",null,"Para crear una instancia de esta clase utilizamos la palabra clave new:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const person = new Person("Pedro");\nperson.sayName(); // imprime "Pedro"\n')),(0,o.kt)("p",null,"Las clases en JavaScript no son m\xe1s que una sintaxis alternativa a los prototipos. El ejemplo anterior se convierte en algo parecido a lo siguiente:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const Person = function(name) {\n  this.name = name;\n};\n\nPerson.prototype.sayName = function() {\n  console.log(this.name);\n}\n")),(0,o.kt)("h3",{id:"herencia"},"Herencia"),(0,o.kt)("p",null,"Con las clases podemos implementar herencia utilizando la palabra ",(0,o.kt)("inlineCode",{parentName:"p"},"extends")," ","(","al igual que otros lenguajes que utilizan clases",")",":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"class Rectangle {\n  constructor(length, width) {\n    this.length = length;\n    this.width: width;\n  }\n\n  getArea() {\n    return this.length * this.width;\n  }\n}\n\nclass Square extends Rectangle {\n  constructor(side) {\n    super(side, side);\n  }\n}\n")),(0,o.kt)("p",null,"En este ejemplo estamos definiendo una clase ",(0,o.kt)("inlineCode",{parentName:"p"},"Square")," que extiende ","(","o hereda",")"," de otra clase llamada ",(0,o.kt)("inlineCode",{parentName:"p"},"Rectangle"),". F\xedjate que en el constructor de ",(0,o.kt)("inlineCode",{parentName:"p"},"Square")," estamos utilizando la palabra clave ",(0,o.kt)("inlineCode",{parentName:"p"},"super")," para llamar el constructor de ",(0,o.kt)("inlineCode",{parentName:"p"},"Rectangle"),"."),(0,o.kt)("h2",{id:"m\xf3dulos"},"M\xf3dulos"),(0,o.kt)("p",null,"Los m\xf3dulos permiten organizar mejor el c\xf3digo y evitar colisiones de nombres."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Nota:")," En este momento ","(","Diciembre 2017",")"," Node.js a\xfan no soporta m\xf3dulos de ES6 ","(","mucho menos los navegadores",")"," y necesitar\xedas transpilar tu c\xf3digo con Babel si quieres utilizar esta funcionalidad. ","(","Desde la 8.5.0 de Node.js puedes utilizar m\xf3dulos renombrando los archivos con la extensi\xf3n ",(0,o.kt)("inlineCode",{parentName:"p"},".mjs")," y agregando la opci\xf3n ",(0,o.kt)("inlineCode",{parentName:"p"},"--experimental-modules"),")","."),(0,o.kt)("h3",{id:"definiendo-un-m\xf3dulo"},"Definiendo un m\xf3dulo"),(0,o.kt)("p",null,"Cada archivo de JavaScript ahora es un m\xf3dulo. Por defecto, las variables que definas en ese archivo van a ser visibles \xfanicamente en ese archivo. Para exportar una variable y que sea visible en otros m\xf3dulos debes usar la palabra clave ",(0,o.kt)("inlineCode",{parentName:"p"},"export"),". Por ejemplo, en un archivo llamado ",(0,o.kt)("inlineCode",{parentName:"p"},"module1.js"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// esta variable es visible s\xf3lo en este archivo\nconst a = 5;\n\n// esta variable es visible en otros m\xf3dulos\nexport const b = 7;\n")),(0,o.kt)("p",null,"Adem\xe1s de variables, puedes exportar clases y funciones."),(0,o.kt)("h3",{id:"importando-un-m\xf3dulo"},"Importando un m\xf3dulo"),(0,o.kt)("p",null,"Para importar un m\xf3dulo en otro archivo utiliza la palabra clave ",(0,o.kt)("inlineCode",{parentName:"p"},"import"),". Por ejemplo, en un archivo ",(0,o.kt)("inlineCode",{parentName:"p"},"module2.js")," podr\xedas importar todas las variables, clases y funciones que hallamos exportado en ",(0,o.kt)("inlineCode",{parentName:"p"},"module1.js"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'import * as m1 from "./module1.js";\n\nconsole.log(m1.b); // 7\n')),(0,o.kt)("p",null,"En este ejemplo, estamos almacenando todas los nombres ","(","variables, clases, funciones, etc.",")"," que se hayan definido en el archivo ",(0,o.kt)("inlineCode",{parentName:"p"},"mmodule1.js")," dentro de un objeto almacenado en la variable ",(0,o.kt)("inlineCode",{parentName:"p"},"m1"),"."),(0,o.kt)("h3",{id:"exportando-valores-por-defecto"},"Exportando valores por defecto"),(0,o.kt)("p",null,"Es muy com\xfan exportar un \xfanico nombre desde un archivo y eso nos permite tomar algunos atajos. Para exportar ese \xfanico nombre utiliza la palabra clave ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," despu\xe9s de ",(0,o.kt)("inlineCode",{parentName:"p"},"export"),". Por ejemplo, en ",(0,o.kt)("inlineCode",{parentName:"p"},"module1.js"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"export default const b = 7;\n")),(0,o.kt)("p",null,"Y para utilizar este valor por defecto en ",(0,o.kt)("inlineCode",{parentName:"p"},"module2.js"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'import b from "./module1.js" // realmente le puedes poner el nombre que quieras a la variable\n\nconsole.log(b); // 7\n')))}d.isMDXComponent=!0}}]);