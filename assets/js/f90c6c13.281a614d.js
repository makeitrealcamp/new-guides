"use strict";(self.webpackChunkmir_guia=self.webpackChunkmir_guia||[]).push([[2345],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>g});var r=t(7294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var s=r.createContext({}),d=function(e){var a=r.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},m=function(e){var a=d(e.components);return r.createElement(s.Provider,{value:a},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},p=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=d(t),p=n,g=c["".concat(s,".").concat(p)]||c[p]||u[p]||o;return t?r.createElement(g,l(l({ref:a},m),{},{components:t})):r.createElement(g,l({ref:a},m))}));function g(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var o=t.length,l=new Array(o);l[0]=p;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i[c]="string"==typeof e?e:n,l[1]=i;for(var d=2;d<o;d++)l[d]=t[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},2137:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var r=t(7462),n=(t(7294),t(3905));const o={},l=void 0,i={unversionedId:"algoritmos/ordenamiento",id:"algoritmos/ordenamiento",title:"ordenamiento",description:"Algoritmos de ordenamiento",source:"@site/docs/algoritmos/ordenamiento.md",sourceDirName:"algoritmos",slug:"/algoritmos/ordenamiento",permalink:"/docs/algoritmos/ordenamiento",draft:!1,editUrl:"https://github.com/makeitrealcamp/new-guides/tree/main/docs/algoritmos/ordenamiento.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Recursi\xf3n",permalink:"/docs/algoritmos/recursion"},next:{title:"Algoritmos de b\xfasqueda",permalink:"/docs/algoritmos/busqueda"}},s={},d=[{value:"Algoritmos de ordenamiento",id:"algoritmos-de-ordenamiento",level:2},{value:"Selection sort",id:"selection-sort",level:2},{value:"Insertion sort",id:"insertion-sort",level:2},{value:"Bubble sort",id:"bubble-sort",level:2},{value:"Merge sort",id:"merge-sort",level:2}],m={toc:d},c="wrapper";function u(e){let{components:a,...t}=e;return(0,n.kt)(c,(0,r.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"algoritmos-de-ordenamiento"},"Algoritmos de ordenamiento"),(0,n.kt)("p",null,"En este cap\xedtulo hablaremos de varios algoritmos de ordenamiento y analizaremos su complejidad."),(0,n.kt)("p",null,"La entrada de todos estos algoritmos es una lista de n\xfameros enteros. La lista podr\xeda estar ordenada, aunque generalmente no lo va a estar. Los n\xfameros no van a ser secuenciales necesariamente, es decir, una lista podr\xeda ser ",(0,n.kt)("inlineCode",{parentName:"p"},"[32, 5, 27]"),"."),(0,n.kt)("p",null,"El resultado siempre es es una lista que contiene los mismos n\xfameros de la lista de entrada pero ordenados de menor a mayor."),(0,n.kt)("h2",{id:"selection-sort"},"Selection sort"),(0,n.kt)("p",null,"Intuitivamente, una forma de ordenar una lista ser\xeda la siguiente:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Recorrer la lista y encontrar el menor."),(0,n.kt)("li",{parentName:"ol"},"Insertar el elemento en otra lista y eliminar el elemento de la lista original."),(0,n.kt)("li",{parentName:"ol"},"Volver al paso 1 hasta que la lista original est\xe9 vac\xeda.")),(0,n.kt)("p",null,"Este algoritmo que acabamos de describir se le conoce como ",(0,n.kt)("strong",{parentName:"p"},"selection sort")," y su complejidad es O(n^2). Este algoritmo tiene la ventaja de ser simple pero la desventaja de que siempre tenemos que recorrer la lista original as\xed el menor est\xe9 en la primera posici\xf3n que comparemos (porque no sabemos que va a ser el menor hasta que terminemos de recorrer toda la lista)."),(0,n.kt)("h2",{id:"insertion-sort"},"Insertion sort"),(0,n.kt)("p",null,"Este algoritmo recorre cada elemento de la lista y va creando una nueva lista ordenada ",(0,n.kt)("strong",{parentName:"p"},"insertando")," el elemento en la posici\xf3n correcta."),(0,n.kt)("p",null,"A diferencia del ",(0,n.kt)("strong",{parentName:"p"},"selection sort")," es muy eficiente si la lista ya est\xe1 ordenada (o casi ordenada) pero su complejidad sigue siendo O(n^2)."),(0,n.kt)("h2",{id:"bubble-sort"},"Bubble sort"),(0,n.kt)("p",null,"Este algoritmo recorre la lista varias veces comparando pares e intercambi\xe1ndolos para que queden ordenados. El algoritmo termina cuando no es necesario hacer ning\xfan intercambio."),(0,n.kt)("h2",{id:"merge-sort"},"Merge sort"),(0,n.kt)("p",null,"Este es uno de los algoritmos m\xe1s eficientes con una complejidad de O(n log n). Es un algoritmo basado en recursi\xf3n y en la idea de que es m\xe1s f\xe1cil unir dos listas previamente ordenadas que tratar con una gran lista desordenada."),(0,n.kt)("p",null,"Como es un algoritmo recursivo debemos definir los casos triviales y los generales. El caso trivial ocurre cuando la lista es vac\xeda o tiene un \xfanico elemento."),(0,n.kt)("p",null,"El caso general divide la lista en dos, llama recursivamente la funci\xf3n para cada una de las listas y despu\xe9s las une de forma ordenada."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"MergeSort(lista)\n  Si la lista es vac\xeda o tiene un elemento\n    retorne la lista\n  De lo contrario\n    divida la lista en dos (lista1 y lista2)\n    lista1 = MergeSort(lista1)\n    lista2 = MergeSort(lista2)\n    mezcle lista1 y lista2\n    retorne la lista mezclada\n")),(0,n.kt)("p",null,"La lista se divide en la mitad. Si la longitud no es par, una de las listas va a tener un elemento de m\xe1s."),(0,n.kt)("p",null,"La uni\xf3n de las listas se hace comparando cada posici\xf3n e insertando en una nueva lista primero el menor y luego el mayor de cada posici\xf3n."),(0,n.kt)("p",null,"##\xa0Quick sort"),(0,n.kt)("p",null,"Este algoritmo tambi\xe9n es muy eficiente con complejidad O(n log n) y se basa en la idea de que es mejor ordenar dos listas independientes y despu\xe9s unirlas."),(0,n.kt)("p",null,"En el quick sort se selecciona un valor de la lista (de forma aleatoria o el de la mitad) llamado el ",(0,n.kt)("strong",{parentName:"p"},"pivote"),". Se empieza a recorrer el arreglo desde los extremos intercambiando los elementos para que todos los que sean menores al ",(0,n.kt)("strong",{parentName:"p"},"pivote")," queden a la izquierda de todos los elementos mayores al pivote."),(0,n.kt)("p",null,"Eso crea una divisi\xf3n natural que se utiliza para ordenar las listas de forma recursiva y al final unirlas. La lista se divide en dos y se vuelve a aplicar quicksort a cada uno de las listas. Por \xfaltimo se unen las dos listas ordenadas."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"QuickSort(lista)\n  Si la lista es vac\xeda o tiene un elemento\n    retorne la lista\n  De lo contrario\n    seleccione el pivote (p.e. elemento de la mitad de la lista)\n    recorra la lista desde los extremos intercambiando los elementos\n    divida la lista en dos (lista1 y lista 2)\n    lista1 = QuickSort(lista1)\n    lista2 = Quicksort(lista2)\n    una lista1 y lista2\n    retorne la lista unida\n")))}u.isMDXComponent=!0}}]);